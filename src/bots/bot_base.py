from gui.popup import show_confirm_box, show_alert_box
from trade_platforms.test_wrapper import TestWrapper
from trade_platforms.validation_wrapper import ValidationWrapper
from trade_platforms.platform_wrapper_base import PlatformWrapper

import copy
from datetime import timedelta
from enum import Enum
import pandas as pd
import plotly.express as px
from typing import List


# Defines the different running modes.
class Mode(Enum):
    # running the bot on test data sets detached from any platform
    Test = 0
    # Tunning bot on live platform data, but with simulated actions
    # (no action order is made on the platform)
    Validation = 1
    # Live mode with real platform actions (!!!Use it with care, it can cost you a lot!!!)
    Production = 2


# Possible plot options.
class PlotOptions(Enum):
    # Balance in case the inital balance was traded
    # once at the beginning then traded back at the end
    BalanceIfTradedOnce = 0x0001
    # Start balance
    StartBalance = 0x0002
    # Cumulative quote currency value of all wallets
    BalanceCumulative = 0x0004
    # Quote currency wallet total
    QuoteCurrencyTotal = 0x0008
    # Quote currency traded amount within time window
    QuoteCurrencyInTimeWindow = 0x0010
    # Quote currency free amount
    QuoteCurrencyFree = 0x0020
    # Base currency traded amount within time window
    BaseCurrencyBalanceInWindow = 0x0040
    # Base currency total amount.
    BaseCurrencyTotal = 0x0080
    # Base currency free amount.
    BaseCurrencyFree = 0x0100
    # Candle price history
    Candles = 0x0200
    # USD price plot
    USDPlot = 0x0400
    # BTC plots
    BTCPlot = 0x0800


def _isPlotOption(config, option):
    return config & option.value == option.value


class BotBase():
    """Base class to handle generic bot behaviour."""

    def __init__(self, platforms, mode, resolution_sec=60):
        if len(platforms) == 0:
            raise Exception("No trading platform and market defined")
        # A bot can connect to multiple platforms of, multiple markets
        # on the same platform, each of them will be a client instance in this dictionary,
        # where the key is the  platform name (the name is autogenerated
        # based on the platform, base and quote currencies)
        self.platforms = dict()
        for trade_platform in platforms:
            self.platforms[trade_platform.name] = trade_platform
        # Test mode platform client wrapper.
        # Contains all client side functionality for test mode.
        self.testWrapper = TestWrapper(self.platforms, resolution_sec)
        # Validation mode platform client wrapper.
        self.validationWrapper = ValidationWrapper(self.platforms)
        # Run mode. See Mode(Enum).
        self.mode = mode
        # if self.mode == Mode.Production and \
        #         not show_confirm_box("Production Mode! Are you sure?"):
        #     sys.exit(0)
        # Stores the candle resolution in minutes.
        self.resolution_sec = resolution_sec

        # Plotting data
        self.BTC_per_window_of_interest = list()
        self.balance_USD_per_window_of_interest = list()
        self.previous_balances = None
        self.previous_timestamp = None
        self.start_balance = 0
        self.start_balance_BTC = 0
        self.fee = 0
        self.start_price = 0
        self.initial_balance_base_qoute_ratio = 1.0
        self.output_quote = pd.DataFrame({
            "timestamp": [],
            "value": [],
            "type": []})
        self.output_base = pd.DataFrame({
            "timestamp": [],
            "value": [],
            "type": []})

    def _select_platform_wrapper(self, market: list) -> PlatformWrapper:
        """
            Selects the appropriate platform client wrapper.

            Parameters:
                - market (list): stores the strings of the currencies to trade on. Generated market naming is platform specific.

            Returns:
                - (PlatformWrapper): Returns the platform wrapper to be used. 3 options. TestWrapper, ValidationWrapper
                    and Production wrapper.
        """

        if self.mode == Mode.Production:
            if market is None:
                return list(self.platforms.values())[0]
            else:
                platform_name = f"{market[0]}-{market[1]}-{market[2]}"
                if platform_name not in self.platforms:
                    raise Exception(f"{platform_name} is an unknown market name")
                return self.platforms[platform_name]
        elif self.mode == Mode.Validation:
            return self.validationWrapper
        elif self.mode == Mode.Test:
            return self.testWrapper

    def plot_data(self, timestamp, plots=0, config=0):
        """
            Plots the selected data.

            Parameters:
                - timestamp (datetime): stores the timestamp at the time of plotting.
        """
        if _isPlotOption(plots, PlotOptions.Candles):
            self.plot_historical(
                start_date=self.get_start_timestamp().timestamp(),
                end_date=timestamp.timestamp(),
                resolution=self.resolution_sec)

        if _isPlotOption(plots, PlotOptions.USDPlot):
            fig = px.line(
                self.output_quote,
                x="timestamp",
                y="value",
                title='Gain over time USD',
                color="type")
            fig.show()

        if _isPlotOption(plots, PlotOptions.BTCPlot):
            fig = px.line(
                self.output_base,
                x="timestamp",
                y="value",
                title='Gain over time BTC',
                color="type")
            fig.show()

    def init_plot_data(self):
        """Initializes plot data."""
        current_balances = self.get_balances()
        self.previous_balances = copy.deepcopy(current_balances)
        self.previous_timestamp = self.get_start_timestamp()
        self.start_balance = copy.deepcopy(self.get_balances())
        self.fee = self.get_account_info()['takerFee']
        self.start_price = self.get_current_price()

    def accumulate_plot_data(self, timestamp, window_of_interest_min=15, config=0):
        """
            Accumulates plot data.
            Parameters:
                - timestamp (datetime): stores the timestamp at the time of accumulation."""
        # Generic tasks, collecting plot data within the window of interest
        if (timestamp - self.previous_timestamp >= timedelta(
                seconds=window_of_interest_min * 60)):
            self.BTC_per_window_of_interest.append(0)
            self.balance_USD_per_window_of_interest.append(0)
            current_balances = self.get_balances()
            length = len(self.BTC_per_window_of_interest) - 1
            self.BTC_per_window_of_interest[length] = \
                current_balances['BTC']['total'] - \
                self.previous_balances['BTC']['total']
            length = len(self.balance_USD_per_window_of_interest) - 1
            self.balance_USD_per_window_of_interest[length] = \
                current_balances[self.testWrapper.USD]['total'] - \
                self.previous_balances[self.testWrapper.USD]['total']
            self.previous_timestamp = timestamp
            self.previous_balances = copy.deepcopy(current_balances)

            length = len(self.BTC_per_window_of_interest) - 1
            # self.output_base.loc[len(self.output_base)] = [
            #     timestamp,
            #     self.BTC_per_window_of_interest[length],
            #     "BTC_window"]

            # self.output_base.loc[len(self.output_base)] = [
            #     timestamp,
            #     current_balances['BTC']['total'],
            #     "BTC_cumulative"]

            # self.output_base.loc[len(self.output_base)] = [
            #     timestamp,
            #     current_balances['BTC']['free'],
            #     "BTC_free"]

            start_balance_BTC = \
                self.initial_balance_base_qoute_ratio *\
                self.start_balance[self.testWrapper.USD]['total'] / \
                self.start_price
            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                start_balance_BTC,
                "BTC_start"]

            total = \
                current_balances['BTC']['total'] + \
                current_balances[self.testWrapper.USD]['total'] / self.get_current_price()
            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                total,
                "Total_wealth_BTC"]

            start_balance_USD = \
                (1.0 - self.initial_balance_base_qoute_ratio) * \
                self.start_balance[self.testWrapper.USD]['total']
            fee_deduced = \
                start_balance_USD - \
                start_balance_USD * self.fee
            value_if_sold_once = (fee_deduced / self.start_price)
            volume = start_balance_BTC + value_if_sold_once
            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                volume,
                "BTC_if_all_kept"]

            length = len(self.balance_USD_per_window_of_interest) - 1
            # self.output_quote.loc[len(self.output_quote)] = [
            #     timestamp,
            #     self.balance_USD_per_window_of_interest[length],
            #     "USD_window"]

            # self.output_quote.loc[len(self.output_quote)] = [
            #     timestamp,
            #     current_balances[self.testWrapper.USD]['total'],
            #     "USD_cumulative"]

            # self.output_quote.loc[len(self.output_quote)] = [
            #     timestamp,
            #     current_balances['BTC']['usdValue'],
            #     "BTC_USD_value"]

            total = \
                current_balances['BTC']['usdValue'] + \
                current_balances[self.testWrapper.USD]['total']
            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                total,
                "Total_wealth_USD"]

            # self.output_quote.loc[len(self.output_quote)] = [
            #     timestamp,
            #     current_balances[self.testWrapper.USD]['free'],
            #     "USD_free"]

            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                self.start_balance[self.testWrapper.USD]['total'],
                "USD_start"]

            fee_deduced = \
                (value_if_sold_once - value_if_sold_once * self.fee) + start_balance_BTC
            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                fee_deduced * self.get_current_price(),
                "USD_value_if_sold_once"]

    def set_initial_balance_base_qoute_ratio(self, ratio):
        """
            API: Sometimes, we want to start with a mixed balanced, this determines,
            how much is base and how much is in quote currency at the start of the simulation
        """
        if self.mode != Mode.Test and self.mode != Mode.Validation:
            show_alert_box("You are using set_initial_balance_base_qoute_ratio(). \
  It does not do anything in production mode")
            return
        self.initial_balance_base_qoute_ratio = ratio

    ## API: Places an order.
    def place_order(self, market=None, type=None, side=None, price=None, volume=None):
        return self._select_platform_wrapper(market).place_order(
            type, side, price, volume)

    ## API: Cancels the order.
    def cancel_order(self, market=None, order=None):
        return self._select_platform_wrapper(market).cancel_order(order)

    ## API: Cancels the order.
    def get_cycle_timestamp(self):
        return self._select_platform_wrapper(None).get_cycle_timestamp()

    ## API: Appends additional info to the cyclic print
    def append_to_cyclic_message(self, message):
        return self._select_platform_wrapper(None).append_to_cyclic_message(message)

    ## API: Returns the orderbook
    def get_orderbook(self):
        return self._select_platform_wrapper(None).get_orderbook()

    ## API: Returns the current price.
    def get_current_price(self, market=None):
        return self._select_platform_wrapper(market).get_current_price()

    ## API: Returns the current candle opening price.
    def get_candle_opening_price(self, market=None):
        return self._select_platform_wrapper(market).get_candle_opening_price()

    ## API: Returns the current candle.
    def get_current_candle(self, market=None):
        return self._select_platform_wrapper(market).get_current_candle()

    ## API: Returns the market data.
    def set_wait_time(self, market=None, wait_time_seconds=0):
        return self._select_platform_wrapper(market).set_wait_time(wait_time_seconds)

    ## API: Returns the market data.
    def market_data(self, market=None):
        return self._select_platform_wrapper(market).market_data()

    ## API: Returns the historical data.
    def historical_data(
            self, market=None, start_time=None, end_time=None, resolution=60 * 60 * 24):
        return self._select_platform_wrapper(market).historical_data(
            start_time, end_time, resolution)

    ## API: Returns the order history.
    def get_order_history(
            self,
            market=None,
            side: str = None,
            order_type: str = None,
            start_time: float = None,
            end_time: float = None) -> List[dict]:
        return self._select_platform_wrapper(market).get_order_history(
            side, order_type, start_time, end_time)

    ## API: Returns the order with order_id
    def get_order(self, order_id, market=None):
        return self._select_platform_wrapper(market).get_order(order_id)

    ## API: Plot historical data
    def plot_historical(
            self, market=None, start_date=None, end_date=None, resolution=None):
        return self._select_platform_wrapper(market).plot_historical(
            start_date, end_date, resolution)

    def get_candle_plot(self, market=0):
        return self._select_platform_wrapper(market).get_candle_plot()

    def show_plot(self, plots, market=0):
        if _isPlotOption(plots, PlotOptions.Candles):
            self._select_platform_wrapper(market).show_candles()

    ## Base class method for running the bot.
    def run(self):
        pass

    ## Evaluates the platform side procedures. For example, returning current market data.
    def evaluate(self, trade, market=None):
        return self._select_platform_wrapper(market).evaluate(trade)

    ## Maintenance work at the end of the iteration.
    def cleanup_iteration(self, market=None):
        return self._select_platform_wrapper(market).cleanup_iteration()

    ## Sets test data interval. Only useful in Test mode.
    def set_test_data_interval(self, test_data_location, start_time, end_time):
        if self.mode != Mode.Test:
            show_alert_box("You are using set_data_interval(). \
It does not do anything in production, or validation mode")
            return
        self.testWrapper.set_data_interval(test_data_location, start_time, end_time)

    ## Sets test or validation start balance. Only useful in Test and Validation mode.
    def set_start_balance(self, balance_USD):
        if self.mode != Mode.Test and self.mode != Mode.Validation:
            show_alert_box("You are using set_start_balance(df). \
It does not do anything in production mode")
            return
        self.testWrapper.set_start_balance(balance_USD)

    ## API: Gets the starting timestamp of the bot execution.
    def get_start_timestamp(self):
        return self._select_platform_wrapper(None).get_start_timestamp()

    ## API: Returns the account info.
    def get_account_info(self, market=None):
        return self._select_platform_wrapper(market).get_account_info()

    ## API: Returns the balances.
    def get_balances(self, market=None):
        return self._select_platform_wrapper(market).get_balances()

    ## Base class method of trading.
    def _trade(self):
        pass
