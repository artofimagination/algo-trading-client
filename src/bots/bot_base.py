from popup import show_confirm_box, show_alert_box
from trade_platforms.test_wrapper import TestWrapper
from trade_platforms.validation_wrapper import ValidationWrapper

import copy
from datetime import timedelta
from enum import Enum
import pandas as pd
import plotly.express as px
import sys
from typing import List


# Defines the different running modes.
class Mode(Enum):
    # running the bot on test data sets detached from any platform
    Test = 0
    # Tunning bot on live platform data, but with simulated actions
    # (no action order is made on the platform)
    Validation = 1
    # Live mode with real platform actions (!!!Use it with care, it can cost you a lot!!!)
    Production = 2


# Possible plot options.
class PlotOptions(Enum):
    # Balance in case the inital balance was traded
    # once at the beginning then traded back at the end
    BalanceIfTradedOnce = 0x0001
    # Start balance
    StartBalance = 0x0002
    # Cumulative quote currency value of all wallets
    BalanceCumulative = 0x0004
    # Quote currency wallet total
    QuoteCurrencyTotal = 0x0008
    # Quote currency traded amount within time window
    QuoteCurrencyInTimeWindow = 0x0010
    # Quote currency free amount
    QuoteCurrencyFree = 0x0020
    # Base currency traded amount within time window
    BaseCurrencyBalanceInWindow = 0x0040
    # Base currency total amount.
    BaseCurrencyTotal = 0x0080
    # Base currency free amount.
    BaseCurrencyFree = 0x0100
    # Candle price history
    Candles = 0x0200


## Base class to handle generic bot behaviour.
class BotBase():
    def __init__(self, platforms, mode):
        if len(platforms) == 0:
            raise Exception("No trading platform and market defined")
        # A bot can connect to multiple platforms of, multiple markets
        # on the same platform, each of them will be a client instance in this dictionary,
        # where the key is the  platform name (the name is autogenerated
        # based on the platform, base and quote currencies)
        self.platforms = dict()
        for trade_platform in platforms:
            self.platforms[trade_platform.name] = trade_platform
        # Test mode platform client wrapper.
        # Contains all client side functionality for test mode.
        self.testWrapper = TestWrapper()
        # Validation mode platform client wrapper.
        self.validationWrapper = ValidationWrapper(self.platforms)
        # Run mode. See Mode(Enum).
        self.mode = mode
        if self.mode == Mode.Production and \
                not show_confirm_box("Production Mode! Are you sure?"):
            sys.exit(0)

        # Plotting data
        self.BTC_per_window_of_interest = list()
        self.balance_USD_per_window_of_interest = list()
        self.previous_balances = None
        self.previous_timestamp = None
        self.start_balance = 0
        self.fee = 0
        self.start_price = 0
        self.output_quote = pd.DataFrame({
            "day": [],
            "value": [],
            "type": []})
        self.output_base = pd.DataFrame({
            "day": [],
            "value": [],
            "type": []})

    ## Selects the appropriate platform client wrapper.
    def _select_platform_wrapper(self, market):
        if self.mode == Mode.Production:
            if market is None:
                return list(self.platforms.values())[0]
            else:
                platform_name = f"{market[0]}-{market[1]}-{market[2]}"
                if platform_name not in self.platforms:
                    raise Exception(f"{platform_name} is an unknown market name")
                return self.platforms[platform_name]
        elif self.mode == Mode.Validation:
            return self.validationWrapper
        elif self.mode == Mode.Test:
            return self.testWrapper

    ## Plots the selected data.
    # @param timestamp timestamp at the time of plotting.
    def plot_data(self, timestamp):
        self.plot_historical(
            start_date=self.get_start_timestamp().timestamp(),
            end_date=timestamp.timestamp(),
            resolution=15)

        fig = px.line(
            self.output_quote,
            x="day",
            y="value",
            title='Gain over time USD',
            color="type")
        fig.show()

        fig = px.line(
            self.output_base,
            x="day",
            y="value",
            title='Gain over time BTC',
            color="type")
        fig.show()

    ## Initializes plot data.
    def init_plot_data(self):
        current_balances = self.get_balances()
        self.previous_balances = copy.deepcopy(current_balances)
        self.previous_timestamp = self.get_start_timestamp()
        self.start_balance = copy.deepcopy(self.get_balances())
        self.fee = self.get_account_info()['takerFee']
        self.start_price = self.get_current_price()

    ## Accumulates plot data.
    #  @param timestamp timestamp at the time of accumulation.
    def accumulate_plot_data(self, timestamp, window_of_interest_seconds=15):
        # Generic tasks, collecting plot data within the window of interest
        if (timestamp - self.previous_timestamp >= timedelta(
                seconds=window_of_interest_seconds)):
            self.BTC_per_window_of_interest.append(0)
            self.balance_USD_per_window_of_interest.append(0)
            current_balances = self.get_balances()
            length = len(self.BTC_per_window_of_interest) - 1
            self.BTC_per_window_of_interest[length] = \
                current_balances['BTC']['total'] - \
                self.previous_balances['BTC']['total']
            length = len(self.balance_USD_per_window_of_interest) - 1
            self.balance_USD_per_window_of_interest[length] = \
                current_balances['USD']['total'] - \
                self.previous_balances['USD']['total']
            self.previous_timestamp = timestamp
            self.previous_balances = copy.deepcopy(current_balances)

            length = len(self.BTC_per_window_of_interest) - 1
            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                self.BTC_per_window_of_interest[length],
                "BTC_window"]

            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                current_balances['BTC']['total'],
                "BTC_cumulative"]

            self.output_base.loc[len(self.output_base)] = [
                timestamp,
                current_balances['BTC']['free'],
                "BTC_free"]

            length = len(self.balance_USD_per_window_of_interest) - 1
            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                self.balance_USD_per_window_of_interest[length],
                "USD_window"]

            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                current_balances['USD']['total'],
                "USD_cumulative"]

            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                current_balances['BTC']['usdValue'],
                "BTC_USD_value"]

            total = \
                current_balances['BTC']['usdValue'] + \
                current_balances['USD']['total']
            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                total,
                "Total_wealth_USD"]

            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                current_balances['USD']['free'],
                "USD_free"]

            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                self.start_balance['USD']['total'],
                "USD_start"]

            fee_deduced = \
                self.start_balance['USD']['total'] - \
                self.start_balance['USD']['total'] * self.fee
            value_if_sold_once = (fee_deduced / self.start_price)
            fee_deduced = value_if_sold_once - value_if_sold_once * self.fee
            self.output_quote.loc[len(self.output_quote)] = [
                timestamp,
                fee_deduced * self.get_current_price(),
                "USD_value_if_sold_once"]

    ## Places an order.
    def place_order(self, market=None, type=None, side=None, price=None, volume=None):
        return self._select_platform_wrapper(market).place_order(
            type, side, price, volume)

    ## Cancels the order.
    def cancel_order(self, market=None, order=None):
        return self._select_platform_wrapper(market).cancel_order(order)

    ## Cancels the order.
    def get_cycle_timestamp(self):
        return self._select_platform_wrapper(None).get_cycle_timestamp()

    ## Returns the orderbook
    def get_orderbook(self):
        return self._select_platform_wrapper(None).get_orderbook()

    ## Returns the current price.
    def get_current_price(self, market=None):
        return self._select_platform_wrapper(market).get_current_price()

    ## Returns the market data.
    def set_wait_time(self, market=None, wait_time_seconds=0):
        return self._select_platform_wrapper(market).set_wait_time(wait_time_seconds)

    ## Returns the market data.
    def market_data(self, market=None):
        return self._select_platform_wrapper(market).market_data()

    ## Returns the historical data.
    def historical_data(
            self, market=None, start_time=None, end_time=None, resolution=60 * 60 * 24):
        return self._select_platform_wrapper(market).historical_data(
            start_time, end_time, resolution)

    ## Returns the order history.
    def get_order_history(
            self,
            market=None,
            side: str = None,
            order_type: str = None,
            start_time: float = None,
            end_time: float = None) -> List[dict]:
        return self._select_platform_wrapper(market).get_order_history(
            side, order_type, start_time, end_time)

    ## Plot historical data
    def plot_historical(
            self, market=None, start_date=None, end_date=None, resolution=None):
        return self._select_platform_wrapper(market).plot_historical(
            start_date, end_date, resolution)

    ## Base class method for running the bot.
    def run(self):
        pass

    ## Evaluates the platform side procedures. For example, returning current market data.
    def evaluate(self, trade, market=None):
        return self._select_platform_wrapper(market).evaluate(trade)

    ## Maintenance work at the end of the iteration.
    def cleanup_iteration(self, market=None):
        return self._select_platform_wrapper(market).cleanup_iteration()

    ## Sets test data interval. Only useful in Test mode.
    def set_test_data_interval(self, test_data_location, start_time, end_time):
        if self.mode != Mode.Test:
            show_alert_box("You are using set_data_interval(). \
It does not do anything in production, or validation mode")
            return
        self.testWrapper.set_data_interval(test_data_location, start_time, end_time)

    ## Sets test or validation start balance. Only useful in Test and Validation mode.
    def set_start_balance(self, balance_USD):
        if self.mode != Mode.Test and self.mode != Mode.Validation:
            show_alert_box("You are using set_start_balance(df). \
It does not do anything in production mode")
            return
        self.testWrapper.set_start_balance(balance_USD)

    ## Gets the starting timestamp of the bot execution.
    def get_start_timestamp(self):
        return self._select_platform_wrapper(None).get_start_timestamp()

    ## Returns the account info.
    def get_account_info(self, market=None):
        return self._select_platform_wrapper(market).get_account_info()

    ## Returns the balances.
    def get_balances(self, market=None):
        return self._select_platform_wrapper(market).get_balances()

    ## Base class method of trading.
    def _trade(self):
        pass
