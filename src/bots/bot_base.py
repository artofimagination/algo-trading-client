from enum import Enum
import sys
from typing import List
from popup import show_confirm_box, show_alert_box

from trade_platforms.test_wrapper import TestWrapper
from trade_platforms.validation_wrapper import ValidationWrapper


# Defines the different running modes.
class Mode(Enum):
    # running the bot on test data sets detached from any platform
    Test = 0
    # Tunning bot on live platform data, but with simulated actions
    # (no action order is made on the platform)
    Validation = 1
    # Live mode with real platform actions (!!!Use it with care, it can cost you a lot!!!)
    Production = 2


## Base class to handle generic bot behaviour.
class BotBase():
    def __init__(self, platforms, mode):
        if len(platforms) == 0:
            raise Exception("No trading platform and market defined")
        # A bot can connect to multiple platforms of, multiple markets
        # on the same platform, each of them will be a client instance in this dictionary,
        # where the key is the  platform name (the name is autogenerated
        # based on the platform, base and quote currencies)
        self.platforms = dict()
        for trade_platform in platforms:
            self.platforms[trade_platform.name] = trade_platform
        # Test mode platform client wrapper.
        # Contains all client side functionality for test mode.
        self.testWrapper = TestWrapper()
        # Validation mode platform client wrapper.
        self.validationWrapper = ValidationWrapper(self.platforms)
        # Run mode. See Mode(Enum).
        self.mode = mode
        if self.mode == Mode.Production and \
                not show_confirm_box("Production Mode! Are you sure?"):
            sys.exit(0)

    ## Selects the appropriate platform client wrapper.
    def _select_platform_wrapper(self, market):
        if self.mode == Mode.Production:
            if market is None:
                return list(self.platforms.values())[0]
            else:
                platform_name = f"{market[0]}-{market[1]}-{market[2]}"
                if platform_name not in self.platforms:
                    raise Exception(f"{platform_name} is an unknown market name")
                return self.platforms[platform_name]
        elif self.mode == Mode.Validation:
            return self.validationWrapper
        elif self.mode == Mode.Test:
            return self.testWrapper

    ## Places an order.
    def place_order(self, market=None, type=None, side=None, price=None, volume=None):
        return self._select_platform_wrapper(market).place_order(
            type, side, price, volume)

    ## Cancels the order.
    def cancel_order(self, market=None, order=None):
        return self._select_platform_wrapper(market).cancel_order(order)

    ## Returns the current price.
    def get_current_price(self, market=None):
        return self._select_platform_wrapper(market).get_current_price()

    ## Returns the market data.
    def set_wait_time(self, market=None, wait_time_seconds=0):
        return self._select_platform_wrapper(market).set_wait_time(wait_time_seconds)

    ## Returns the market data.
    def market_data(self, market=None):
        return self._select_platform_wrapper(market).market_data()

    ## Returns the historical data.
    def historical_data(
            self, market=None, start_time=None, end_time=None, resolution=60 * 60 * 24):
        return self._select_platform_wrapper(market).historical_data(
            start_time, end_time, resolution)

    ## Returns the order history.
    def get_order_history(
            self,
            market=None,
            side: str = None,
            order_type: str = None,
            start_time: float = None,
            end_time: float = None) -> List[dict]:
        return self._select_platform_wrapper(market).get_order_history(
            side, order_type, start_time, end_time)

    ## Plot historical data
    def plot_historical(
            self, market=None, start_date=None, end_date=None, resolution=None):
        return self._select_platform_wrapper(market).plot_historical(
            start_date, end_date, resolution)

    ## Base class method for running the bot.
    def run(self):
        pass

    ## Evaluates the platform side procedures. For example, returning current market data.
    def evaluate(self, trade, market=None):
        return self._select_platform_wrapper(market).evaluate(trade)

    ## Maintenance work at the end of the iteration.
    def cleanup_iteration(self, market=None):
        return self._select_platform_wrapper(market).cleanup_iteration()

    ## Sets test data interval. Only useful in Test mode.
    def set_test_data_interval(self, test_data_location, start_time, end_time):
        if self.mode != Mode.Test:
            show_alert_box("You are using set_data_interval(). \
It does not do anything in production, or validation mode")
            return
        self.testWrapper.set_data_interval(test_data_location, start_time, end_time)

    ## Sets test or validation start balance. Only useful in Test and Validation mode.
    def set_start_balance(self, balance_USD):
        if self.mode != Mode.Test and self.mode != Mode.Validation:
            show_alert_box("You are using set_start_balance(df). \
It does not do anything in production mode")
            return
        self.testWrapper.set_start_balance(balance_USD)

    ## Gets the starting timestamp of the bot execution.
    def get_start_timestamp(self):
        return self._select_platform_wrapper(None).get_start_timestamp()

    ## Returns the account info.
    def get_account_info(self, market=None):
        return self._select_platform_wrapper(market).get_account_info()

    ## Returns the balances.
    def get_balances(self, market=None):
        return self._select_platform_wrapper(market).get_balances()

    ## Base class method of trading.
    def _trade(self):
        pass
